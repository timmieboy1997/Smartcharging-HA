blueprint:
  name: "Frank Energie - Smart Battery Manager (V1.6.1)"
  description: >
    **Production Release V1.6.1 - EEPROM Saver Edition**
    
    CHANGE LOG V1.6.1:
    - FIX: Hold mode no longer chases Solar gain. It only writes to inverter if Target SoC > Current SoC (to stop grid charging).
    - Solar Friendly: If battery charges via sun above the hold-target, it remains untouched.
    
    LOGIC:
    1. CHARGE: Price Cheap -> Switch ON, Target SoC = Winter/Summer Target.
    2. HOLD: Price Medium -> Switch ON. If Inverter Target > Current SoC -> Set Target = Current (Stops Grid Charge).
    3. DISCHARGE: Price High -> Switch OFF.
    
    **Supported Languages:** English, Nederlands.
  domain: automation
  source_url: "https://github.com/pwnypower/Smartcharging-HA/blob/main/automation/blueprints/Smartcharging%20frankenergie.yaml"
  input:
    # --- GENERAL SETTINGS ---
    language:
      name: "Notification Language"
      default: "en"
      selector:
        select:
          options:
            - label: "English"
              value: "en"
            - label: "Nederlands"
              value: "nl"

    # --- NOTIFICATIONS ---
    notify_device:
      name: "Notification Device"
      default: []
      selector:
        device:
          integration: mobile_app
    report_time_evening:
      name: "Report Time (Evening)"
      default: "21:30:00"
      selector:
        time:
    report_time_morning:
      name: "Report Time (Morning)"
      default: "08:00:00"
      selector:
        time:

    # --- ENTITIES ---
    battery_reserve_switch:
      name: "Switch: Force Charge"
      description: "The switch that forces the battery to charge from the grid."
      selector:
        entity:
          domain: switch
    target_soc_number:
      name: "Number: Target SoC (Inverter)"
      description: "The entity that controls the max charge % on the inverter."
      selector:
        entity:
          domain: number
          min: 0
          max: 100
    battery_soc_sensor:
      name: "Sensor: Battery SoC"
      description: "Sensor indicating current battery percentage."
      selector:
        entity:
          domain: sensor
          device_class: battery
    frank_price_sensor:
      name: "Sensor: Energy Prices"
      selector:
        entity:
          domain: sensor
    
    # --- MEMORY ---
    last_price_helper:
      name: "Helper: Last Purchase Price"
      selector:
        entity:
          domain: input_number

    # --- STRATEGY ---
    target_soc_morning_min:
      name: "Morning Guarantee (%)"
      default: 50
      selector:
        number:
          min: 0
          max: 100
          unit_of_measurement: "%"
    target_soc_winter:
      name: "Target SoC (Winter/Dark)"
      default: 90
      selector:
        number:
          min: 10
          max: 100
    target_soc_summer:
      name: "Target SoC (Summer/Sunny)"
      default: 30
      selector:
        number:
          min: 10
          max: 100
    summer_solar_threshold:
      name: "Summer Threshold (kWh)"
      default: 15
      selector:
        number:
          min: 0
          max: 100
          unit_of_measurement: "kWh"

    # --- PROFITABILITY ---
    min_profit_margin_winter:
      name: "Margin Winter/Dark (%)"
      default: 5
      selector:
        number:
          min: 0
          max: 100
          unit_of_measurement: "%"
    min_profit_margin_summer:
      name: "Margin Summer/Sunny (%)"
      default: 20
      selector:
        number:
          min: 0
          max: 100
          unit_of_measurement: "%"

    # --- TIME SLOTS ---
    night_start:
      name: "Night Slot Start"
      default: "00:00:00"
      selector:
        time:
    night_end:
      name: "Night Slot End"
      default: "06:00:00"
      selector:
        time:
    day_start:
      name: "Day Slot Start"
      default: "12:00:00"
      selector:
        time:
    day_end:
      name: "Day Slot End"
      default: "15:00:00"
      selector:
        time:
    day_end:
      name: "Day Slot End"
      default: "15:00:00"
      selector:
        time:

    # --- ADVANCED ---
    solar_forecast_today:
      name: "Sensor: Solar Forecast Today"
      selector:
        entity:
          domain: sensor
    solar_forecast_tomorrow:
      name: "Sensor: Solar Forecast Tomorrow"
      selector:
        entity:
          domain: sensor
    boost_switch:
      name: "Switch: Manual Boost"
      default: []
      selector:
        entity:
          domain: input_boolean
    battery_capacity_kwh:
      name: "Battery Capacity (kWh)"
      default: 10
      selector:
        number:
          min: 1
          max: 100
          step: 0.1
    charge_power_kw:
      name: "Max Charge Speed (kW)"
      default: 3.0
      selector:
        number:
          min: 0.1
          max: 22
          step: 0.1
    safety_factor:
      name: "BMS Safety Factor"
      default: 1.5
      selector:
        number:
          min: 1.0
          max: 4.0
          step: 0.1
    max_price_cap:
      name: "Max Price Cap (â‚¬)"
      default: 0.35
      selector:
        number:
          min: 0
          max: 2.0
          step: 0.01
          mode: box
          unit_of_measurement: "â‚¬"
    emergency_soc:
      name: "Emergency Floor (%)"
      default: 10
      selector:
        number:
          min: 0
          max: 100
          unit_of_measurement: "%"

variables:
  # Inputs
  battery_reserve_switch: !input battery_reserve_switch
  target_soc_number: !input target_soc_number
  battery_soc_sensor: !input battery_soc_sensor
  frank_price_sensor: !input frank_price_sensor
  last_price_helper: !input last_price_helper
  boost_switch: !input boost_switch
  notify_device: !input notify_device
  target_soc_morning_min: !input target_soc_morning_min
  night_start: !input night_start
  night_end: !input night_end
  day_start: !input day_start
  day_end: !input day_end
  solar_forecast_today: !input solar_forecast_today
  solar_forecast_tomorrow: !input solar_forecast_tomorrow
  summer_solar_threshold: !input summer_solar_threshold
  min_profit_margin_winter: !input min_profit_margin_winter
  min_profit_margin_summer: !input min_profit_margin_summer
  target_soc_winter: !input target_soc_winter
  target_soc_summer: !input target_soc_summer
  battery_capacity_kwh: !input battery_capacity_kwh
  charge_power_kw: !input charge_power_kw
  safety_factor: !input safety_factor
  max_price_cap: !input max_price_cap
  emergency_soc: !input emergency_soc
  language: !input language

trigger:
  - platform: time_pattern
    minutes: "59"
    id: "hourly_sync"
  - platform: time_pattern
    minutes: "/5"
    id: "periodic_check"
  - platform: time
    at: !input report_time_evening
    id: "report"
  - platform: time
    at: !input report_time_morning
    id: "report"
  - platform: state
    entity_id: !input boost_switch
    to: "on"
    id: "boost"
  - platform: numeric_state
    entity_id: !input battery_soc_sensor
    below: !input emergency_soc
    id: "emergency"

action:
  - variables:
      current_soc: "{{ states(battery_soc_sensor) | float(0) }}"
      has_notify_device: "{{ notify_device != [] }}"
      
      # 1. TIME & SLOTS
      target_ts: >-
        {% if trigger.id == 'hourly_sync' %} {{ as_timestamp(now()) + 120 }}
        {% else %} {{ as_timestamp(now()) }} {% endif %}
      target_hour: "{{ (target_ts | timestamp_custom('%H')) | int }}"
      
      is_in_slot: >-
        {% set h = target_hour %}
        {% set ns = night_start.split(':')[0]|int %} {% set ne = night_end.split(':')[0]|int %}
        {% set ds = day_start.split(':')[0]|int %}   {% set de = day_end.split(':')[0]|int %}
        {% if ns > ne %} {% set n = (h >= ns or h < ne) %} {% else %} {% set n = (h >= ns and h < ne) %} {% endif %}
        {% if ds > de %} {% set d = (h >= ds or h < de) %} {% else %} {% set d = (h >= ds and h < de) %} {% endif %}
        {{ n or d }}
      
      is_night_now: >-
        {% set h = target_hour %}
        {% set ns = night_start.split(':')[0]|int %} {% set ne = night_end.split(':')[0]|int %}
        {% if ns > ne %} {{ h >= ns or h < ne }} {% else %} {{ h >= ns and h < ne }} {% endif %}

      # 2. PRICE DATA
      raw: "{{ state_attr(frank_price_sensor, 'prices') }}"
      prices_json: >-
        {% if raw %}
          {% set text = raw | string %}
          {% set matches = text | regex_findall("datetime\\.datetime\\((\\d+), (\\d+), (\\d+), (\\d+), (\\d+).*?price': ([0-9.]+)") %}
          [
          {%- for m in matches %}
            {% set ts_val = as_timestamp("%04d-%02d-%02dT%02d:%02d:00" | format(m[0]|int, m[1]|int, m[2]|int, m[3]|int, m[4]|int)) %}
            {% if language == 'nl' %} {% set dl = 'Vandaag' if m[2]|int == now().day else 'Morgen' %}
            {% else %} {% set dl = 'Today' if m[2]|int == now().day else 'Tomorrow' %} {% endif %}
            { "local_hour": {{ m[3]|int }}, "day_str": "{{ dl }}", "ts": {{ ts_val }}, "price": {{ m[5]|float }} }
            {{ "," if not loop.last }}
          {%- endfor %}
          ]
        {% else %} [] {% endif %}

      target_price: >-
        {% set ns = namespace(price=999.0) %}
        {% for item in prices_json %}
           {% if item.ts <= target_ts and (item.ts + 3600) > target_ts %} {% set ns.price = item.price %} {% endif %}
        {% endfor %}
        {{ ns.price }}

      # 3. FILTERING & AVERAGES
      filtered_data: >-
        {% set output = namespace(price_list=[], avg=0, slot_data=[], global_sum=0, global_count=0, night_prices=[]) %}
        {% set history_cutoff = as_timestamp(now()) - 3600 %}
        {% if prices_json %}
           {% set ns = night_start.split(':')[0]|int %} {% set ne = night_end.split(':')[0]|int %}
           {% set ds = day_start.split(':')[0]|int %}   {% set de = day_end.split(':')[0]|int %}
           {% for item in prices_json %}
              {% if item.ts >= history_cutoff %}
                  {% set output.global_sum = output.global_sum + item.price %}
                  {% set output.global_count = output.global_count + 1 %}
                  {% set h = item.local_hour %}
                  {% if ns > ne %} {% set in_n = (h >= ns or h < ne) %} {% else %} {% set in_n = (h >= ns and h < ne) %} {% endif %}
                  {% if ds > de %} {% set in_d = (h >= ds or h < de) %} {% else %} {% set in_d = (h >= ds and h < de) %} {% endif %}
                  {% if in_n or in_d %}
                     {% set output.price_list = output.price_list + [item.price] %}
                     {% set output.slot_data = output.slot_data + [item] %}
                  {% endif %}
                  {% if in_n %} {% set output.night_prices = output.night_prices + [item.price] %} {% endif %}
              {% endif %}
           {% endfor %}
        {% endif %}
        {% set global_avg = (output.global_sum / output.global_count) if output.global_count > 0 else 999.0 %}
        {"all": {{ output.price_list }}, "night": {{ output.night_prices }}, "global_avg": {{ global_avg }}, "slot_data": {{ output.slot_data }}}

      sorted_all: "{{ filtered_data.all | sort }}"
      sorted_night: "{{ filtered_data.night | sort }}"
      avg_price_day: "{{ filtered_data.global_avg }}"

      # 4. STRATEGY & PROFIT
      forecast_tomorrow_val: "{{ states(solar_forecast_tomorrow) | float(0) }}"
      relevant_solar: >-
        {% if now().hour >= 14 %} {{ forecast_tomorrow_val }}
        {% else %} {{ states(solar_forecast_today) | float(0) }} {% endif %}
      
      dynamic_target_soc: >-
        {% if relevant_solar > summer_solar_threshold %} {{ target_soc_summer }}
        {% else %} {{ target_soc_winter }} {% endif %}

      current_profit_margin: >-
        {% if relevant_solar > summer_solar_threshold %} {{ min_profit_margin_summer }}
        {% else %} {{ min_profit_margin_winter }} {% endif %}

      profit_price_limit: "{{ avg_price_day * (1 - (current_profit_margin / 100)) }}"
      
      holding_limit: >-
        {% set stored = states(last_price_helper) | float(0) %}
        {% if stored > 0 %} {{ stored * (1 + (current_profit_margin / 100)) }}
        {% else %} {{ target_price * (1 + (current_profit_margin / 100)) }} {% endif %}

      # 5. THRESHOLDS & DECISIONS
      hours_calc: >-
        {% set def_m = target_soc_morning_min - current_soc %}
        {% set h_m = ((def_m/100*battery_capacity_kwh/charge_power_kw)*safety_factor)|round(0,'ceil')|int if def_m > 0 else 0 %}
        {% set def_t = dynamic_target_soc - current_soc %}
        {% set h_s = (def_t/100*battery_capacity_kwh/charge_power_kw)|round(0,'ceil')|int if def_t > 0 else 0 %}
        {"morning": {{ h_m }}, "strict": {{ h_s }}}

      hours_morning: "{{ hours_calc.morning }}"
      hours_strict: "{{ hours_calc.strict }}"

      threshold_morning: >-
        {% if sorted_night and hours_morning > 0 %}
           {% set idx = (hours_morning - 1) if (hours_morning - 1) < sorted_night|length else (sorted_night|length - 1) %}
           {{ sorted_night[idx] }}
        {% else %} -999 {% endif %}

      threshold_strict: >-
        {% if sorted_all and hours_strict > 0 %}
           {% set idx = (hours_strict - 1) if (hours_strict - 1) < sorted_all|length else (sorted_all|length - 1) %}
           {{ sorted_all[idx] }}
        {% else %} -999 {% endif %}

      should_charge: >-
        {% set c1 = (is_night_now and target_price <= threshold_morning) %}
        {% set c2 = (is_in_slot and target_price <= threshold_strict) %}
        {% set c3 = (is_in_slot and target_price < profit_price_limit) %}
        {{ c1 or c2 or c3 }}
      
      should_profit_take: "{{ target_price > holding_limit }}"
      
      # HOLD: Not charging AND Not Profit Taking AND Battery below target AND In a valid slot
      should_hold: >-
        {{ not should_charge and not should_profit_take and current_soc < dynamic_target_soc and is_in_slot }}

  - choose:
      # A. REPORTING
      - conditions:
          - condition: trigger
            id: "report"
        sequence:
          - if:
              - condition: template
                value_template: "{{ has_notify_device }}"
            then:
              - domain: mobile_app
                type: notify
                device_id: !input notify_device
                message: >-
                  {% if language == 'nl' %}
                    ðŸ“Š **Batterij Plan**
                    SoC: {{ current_soc }}% -> Doel: {{ dynamic_target_soc }}%
                    Status: {{ 'ðŸŸ¢ Laden' if should_charge else ('ðŸŸ  Vasthouden' if should_hold else 'ðŸ”´ Ontladen') }}
                    
                    Garantie (<): â‚¬{{ threshold_morning | round(3) }}
                    Laden onder: â‚¬{{ threshold_strict | round(3) }}
                  {% else %}
                    ðŸ“Š **Battery Plan**
                    SoC: {{ current_soc }}% -> Target: {{ dynamic_target_soc }}%
                    Status: {{ 'ðŸŸ¢ Charge' if should_charge else ('ðŸŸ  Hold' if should_hold else 'ðŸ”´ Discharge') }}
                  {% endif %}

      # B. BOOST / EMERGENCY
      - conditions:
          - condition: or
            conditions:
              - condition: trigger
                id: "boost"
              - condition: trigger
                id: "emergency"
        sequence:
          - service: switch.turn_on
            target:
              entity_id: !input battery_reserve_switch
          - service: number.set_value
            target:
              entity_id: !input target_soc_number
            data:
              value: 100
          - if:
              - condition: template
                value_template: "{{ has_notify_device }}"
            then:
              - domain: mobile_app
                type: notify
                device_id: !input notify_device
                message: "ðŸš€ Boost!"

      # C. CHARGE MODE (Cheap Price)
      - conditions:
          - condition: template
            value_template: "{{ should_charge }}"
          - condition: template
            value_template: "{{ target_price < max_price_cap }}"
          - condition: template
            value_template: "{{ current_soc < dynamic_target_soc }}"
        sequence:
          - service: switch.turn_on
            target:
              entity_id: !input battery_reserve_switch
          
          # Only write if Inverter Target is not yet the Winter/Summer Target
          - if:
              - condition: template
                value_template: "{{ abs(states(target_soc_number)|float(0) - dynamic_target_soc) > 1 }}"
            then:
              - service: number.set_value
                target:
                  entity_id: !input target_soc_number
                data:
                  value: "{{ dynamic_target_soc }}"

          - service: input_number.set_value
            target:
              entity_id: !input last_price_helper
            data:
              value: "{{ target_price }}"

          - if:
              - condition: template
                value_template: "{{ has_notify_device and is_state(battery_reserve_switch, 'off') }}"
            then:
              - domain: mobile_app
                type: notify
                device_id: !input notify_device
                message: "ðŸ”‹ Start Laden (â‚¬{{ target_price|round(3) }})"

      # D. HOLD MODE (Medium Price)
      - conditions:
          - condition: template
            value_template: "{{ should_hold }}"
        sequence:
          - service: switch.turn_on
            target:
              entity_id: !input battery_reserve_switch
          
          # CRITICAL CHECK: Only write if the INVERTER setting is HIGHER than current SoC.
          # Example: Inverter says "Charge to 90%", but we want to HOLD at 50%. -> Write 50%.
          # Example: Inverter says "Charge to 50%", but sun pushed battery to 55%. -> Do NOTHING.
          - if:
              - condition: template
                value_template: "{{ states(target_soc_number)|float(0) > (current_soc + 1) }}"
            then:
              - service: number.set_value
                target:
                  entity_id: !input target_soc_number
                data:
                  value: "{{ current_soc | int }}"

      # E. DISCHARGE / PROFIT MODE
      - conditions:
          - condition: or
            conditions:
              - condition: template
                value_template: "{{ not should_charge and not should_hold }}"
              - condition: template
                value_template: "{{ should_profit_take }}"
        sequence:
          - service: switch.turn_off
            target:
              entity_id: !input battery_reserve_switch
          
          # We do NOT change the Target SoC here to save EEPROM.
          # Switching "Force Charge" to OFF is usually enough to start self-consumption.

mode: single